import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
import { HistoricalDataService, CoinHistoricalData, HistoricalDataPoint } from '../historical-data.service';

describe('HistoricalDataService', () => {
  let service: HistoricalDataService;
  let httpMock: HttpTestingController;

  const mockCoinData: CoinHistoricalData = {
    symbol: 'BTC',
    name: 'Bitcoin',
    coinGeckoId: 'bitcoin',
    lastUpdated: '2023-01-01T00:00:00Z',
    dataPoints: 365,
    earliestDate: '2022-01-01',
    latestDate: '2023-01-01',
    data: [
      { date: '2022-01-01', price: 47000, marketCap: 890000000000, volume24h: 30000000000 },
      { date: '2022-06-01', price: 30000, marketCap: 570000000000, volume24h: 20000000000 },
      { date: '2022-12-31', price: 16500, marketCap: 318000000000, volume24h: 15000000000 }
    ]
  };

  const baseUrl = 'https://stcrypto9rc2a6.blob.core.windows.net/historical-data';

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [HistoricalDataService]
    });

    service = TestBed.inject(HistoricalDataService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpMock.verify();
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  describe('getCoinHistoricalData', () => {
    it('should fetch coin data successfully', () => {
      service.getCoinHistoricalData('BTC').subscribe(data => {
        expect(data).toEqual(mockCoinData);
        expect(data.symbol).toBe('BTC');
        expect(data.data.length).toBe(3);
      });

      const req = httpMock.expectOne(`${baseUrl}/btc.json`);
      expect(req.request.method).toBe('GET');
      req.flush(mockCoinData);
    });

    it('should convert symbol to lowercase for API call', () => {
      service.getCoinHistoricalData('ETH').subscribe();

      const req = httpMock.expectOne(`${baseUrl}/eth.json`);
      expect(req.request.url).toContain('eth.json');
      req.flush(mockCoinData);
    });

    it('should handle HTTP errors', () => {
      service.getCoinHistoricalData('INVALID').subscribe({
        next: () => fail('Should have failed'),
        error: (error) => {
          expect(error).toBeDefined();
        }
      });

      const req = httpMock.expectOne(`${baseUrl}/invalid.json`);
      req.flush('Not found', { status: 404, statusText: 'Not Found' });
    });

    it('should retry failed requests', () => {
      let attempts = 0;
      service.getCoinHistoricalData('BTC').subscribe({
        next: () => {},
        error: () => {
          expect(attempts).toBe(3); // Initial + 2 retries
        }
      });

      // First attempt
      let req = httpMock.expectOne(`${baseUrl}/btc.json`);
      attempts++;
      req.flush('Server error', { status: 500, statusText: 'Internal Server Error' });

      // First retry
      req = httpMock.expectOne(`${baseUrl}/btc.json`);
      attempts++;
      req.flush('Server error', { status: 500, statusText: 'Internal Server Error' });

      // Second retry
      req = httpMock.expectOne(`${baseUrl}/btc.json`);
      attempts++;
      req.flush('Server error', { status: 500, statusText: 'Internal Server Error' });
    });

    it('should cache successful responses', () => {
      // First call
      service.getCoinHistoricalData('BTC').subscribe(data => {
        expect(data).toEqual(mockCoinData);
      });

      const req = httpMock.expectOne(`${baseUrl}/btc.json`);
      req.flush(mockCoinData);

      // Second call should use cache (no HTTP request)
      service.getCoinHistoricalData('BTC').subscribe(data => {
        expect(data).toEqual(mockCoinData);
      });

      // No additional HTTP requests should be made
      httpMock.expectNone(`${baseUrl}/btc.json`);
    });
  });

  describe('getMultipleCoinData', () => {
    it('should fetch multiple coins in parallel', () => {
      const symbols = ['BTC', 'ETH'];
      const ethData = { ...mockCoinData, symbol: 'ETH', name: 'Ethereum' };

      service.getMultipleCoinData(symbols).subscribe(data => {
        expect(Object.keys(data)).toEqual(['BTC', 'ETH']);
        expect(data['BTC']).toEqual(mockCoinData);
        expect(data['ETH']).toEqual(ethData);
      });

      const btcReq = httpMock.expectOne(`${baseUrl}/btc.json`);
      const ethReq = httpMock.expectOne(`${baseUrl}/eth.json`);

      btcReq.flush(mockCoinData);
      ethReq.flush(ethData);
    });

    it('should handle empty symbol array', () => {
      service.getMultipleCoinData([]).subscribe(data => {
        expect(data).toEqual({});
      });

      httpMock.expectNone(() => true);
    });

    it('should return partial results on partial failures', () => {
      const symbols = ['BTC', 'INVALID'];

      service.getMultipleCoinData(symbols).subscribe(data => {
        expect(data).toEqual({});
      });

      const btcReq = httpMock.expectOne(`${baseUrl}/btc.json`);
      const invalidReq = httpMock.expectOne(`${baseUrl}/invalid.json`);

      btcReq.flush(mockCoinData);
      invalidReq.flush('Not found', { status: 404, statusText: 'Not Found' });
    });
  });

  describe('getCoinDataForDateRange', () => {
    it('should filter data by date range', () => {
      const startDate = new Date('2022-05-01');
      const endDate = new Date('2022-12-31');

      service.getCoinDataForDateRange('BTC', startDate, endDate).subscribe(data => {
        expect(data.length).toBe(2); // Should include 2022-06-01 and 2022-12-31
        expect(data[0].date).toBe('2022-06-01');
        expect(data[1].date).toBe('2022-12-31');
      });

      const req = httpMock.expectOne(`${baseUrl}/btc.json`);
      req.flush(mockCoinData);
    });

    it('should return empty array if no data in range', () => {
      const startDate = new Date('2025-01-01');
      const endDate = new Date('2025-12-31');

      service.getCoinDataForDateRange('BTC', startDate, endDate).subscribe(data => {
        expect(data.length).toBe(0);
      });

      const req = httpMock.expectOne(`${baseUrl}/btc.json`);
      req.flush(mockCoinData);
    });
  });

  describe('getAvailableCoins', () => {
    it('should return list of available coin symbols', () => {
      const coins = service.getAvailableCoins();
      expect(Array.isArray(coins)).toBeTruthy();
      expect(coins.length).toBeGreaterThan(0);
      expect(coins).toContain('BTC');
      expect(coins).toContain('ETH');
    });

    it('should return coins in correct format', () => {
      const coins = service.getAvailableCoins();
      coins.forEach(coin => {
        expect(typeof coin).toBe('string');
        expect(coin.length).toBeGreaterThan(0);
        expect(coin).toMatch(/^[A-Z0-9]+$/); // Should be uppercase alphanumeric
      });
    });
  });

  describe('prefetchCommonCoins', () => {
    it('should prefetch top 20 coins', () => {
      service.prefetchCommonCoins();

      // Should make requests for top coins
      const requests = httpMock.match(() => true);
      expect(requests.length).toBe(20);

      // Respond to all requests
      requests.forEach(req => {
        const symbol = req.request.url.split('/').pop()?.split('.')[0]?.toUpperCase();
        req.flush({ ...mockCoinData, symbol });
      });
    });

    it('should handle errors gracefully during prefetch', () => {
      service.prefetchCommonCoins();

      const requests = httpMock.match(() => true);
      expect(requests.length).toBe(20);

      // Make some requests fail
      requests.slice(0, 5).forEach(req => {
        req.flush('Error', { status: 404, statusText: 'Not Found' });
      });

      // Make others succeed
      requests.slice(5).forEach(req => {
        const symbol = req.request.url.split('/').pop()?.split('.')[0]?.toUpperCase();
        req.flush({ ...mockCoinData, symbol });
      });

      // Should not throw errors
      expect(true).toBeTruthy();
    });
  });

  describe('validateAndTransform', () => {
    it('should validate and transform data correctly', () => {
      const validateAndTransform = (service as any).validateAndTransform.bind(service);
      
      const result = validateAndTransform(mockCoinData, 'BTC');
      
      expect(result).toEqual(mockCoinData);
      expect(result.symbol).toBe('BTC');
    });

    it('should handle missing data fields', () => {
      const validateAndTransform = (service as any).validateAndTransform.bind(service);
      
      const incompleteData = {
        symbol: 'BTC',
        name: 'Bitcoin',
        data: mockCoinData.data
      };
      
      const result = validateAndTransform(incompleteData, 'BTC');
      
      expect(result.symbol).toBe('BTC');
      expect(result.name).toBe('Bitcoin');
      expect(result.data).toEqual(mockCoinData.data);
    });
  });

  describe('caching', () => {
    it('should cache data with timestamp', () => {
      const getFromCache = (service as any).getFromCache.bind(service);
      const setCache = (service as any).setCache.bind(service);
      
      // Set cache
      setCache('btc', mockCoinData);
      
      // Get from cache
      const cachedData = getFromCache('btc');
      expect(cachedData).toEqual(mockCoinData);
    });

    it('should expire cache after timeout', () => {
      const getFromCache = (service as any).getFromCache.bind(service);
      const setCache = (service as any).setCache.bind(service);
      
      // Mock old timestamp
      const oldTimestamp = Date.now() - (2 * 60 * 60 * 1000); // 2 hours ago
      (service as any).cache.set('btc', { data: mockCoinData, timestamp: oldTimestamp });
      
      const cachedData = getFromCache('btc');
      expect(cachedData).toBeNull();
    });
  });

  describe('error handling', () => {
    it('should handle network errors', () => {
      const handleError = (service as any).handleError.bind(service);
      
      const networkError = new ErrorEvent('Network error');
      const error = { error: networkError } as any;
      
      handleError(error, 'BTC').subscribe({
        next: () => fail('Should have failed'),
        error: (err: any) => {
          expect(err).toBeDefined();
        }
      });
    });

    it('should handle HTTP error responses', () => {
      const handleError = (service as any).handleError.bind(service);
      
      const httpError = {
        status: 404,
        statusText: 'Not Found',
        error: { message: 'Coin not found' }
      } as any;
      
      handleError(httpError, 'INVALID').subscribe({
        next: () => fail('Should have failed'),
        error: (err: any) => {
          expect(err).toBeDefined();
        }
      });
    });
  });

  describe('price calculation utilities', () => {
    it('should interpolate prices for missing dates', () => {
      // This would test price interpolation if implemented
      expect(true).toBeTruthy();
    });

    it('should handle edge cases in data', () => {
      const edgeCaseData: CoinHistoricalData = {
        ...mockCoinData,
        data: []
      };

      service.getCoinDataForDateRange('BTC', new Date('2022-01-01'), new Date('2022-12-31'))
        .subscribe(data => {
          expect(data).toEqual([]);
        });

      const req = httpMock.expectOne(`${baseUrl}/btc.json`);
      req.flush(edgeCaseData);
    });
  });

  describe('performance', () => {
    it('should handle large datasets efficiently', () => {
      const largeDataset: CoinHistoricalData = {
        ...mockCoinData,
        data: Array.from({ length: 1000 }, (_, i) => ({
          date: new Date(2022, 0, i + 1).toISOString().split('T')[0],
          price: 47000 + (i * 10),
          marketCap: 890000000000,
          volume24h: 30000000000
        }))
      };

      const startTime = performance.now();
      
      service.getCoinDataForDateRange('BTC', new Date('2022-01-01'), new Date('2022-12-31'))
        .subscribe(data => {
          const endTime = performance.now();
          const duration = endTime - startTime;
          
          expect(duration).toBeLessThan(100); // Should complete in under 100ms
          expect(data.length).toBeGreaterThan(0);
        });

      const req = httpMock.expectOne(`${baseUrl}/btc.json`);
      req.flush(largeDataset);
    });
  });
});